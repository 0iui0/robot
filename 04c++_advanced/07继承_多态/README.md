##  http://robot.czxy.com/docs/cpp/day05/03_inherit/#_1


    继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承类似，例如儿子继承父亲的财产。

    继承（Inheritance）可以理解为一个类从另一个类获取成员变量和成员函数的过程。例如B类 继承于A类，那么 B 就拥有 A 的成员变量和成员函数。被继承的类称为父类或基类，继承的类称为子类或派生类。 子类除了拥有父类的功能之外，还可以定义自己的新成员，以达到扩展的目的。

## is A 和  has A
    大千世界，不是什么东西都能产生继承关系。只有存在某种联系，才能表示有继承关系。如：哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。所以在学习继承后面的内容之前，先说说两个术语 is A 和 has A。

    is A
    is A 是一种继承关系，指的是类的父子继承关系。表达的是一种方式：这个东西是那个东西的一种。例如：长方体与正方体之间--正方体是长方体的一种。正方体继承了长方体的属性，长方体是父类，正方体是子类。

    has A
    has-A 是一种组合关系，是关联关系的一种（一个类中有另一个类型的实例），是整体和部分之间的关系（比如汽车和轮胎之间），并且代表的整体对象负责构建和销毁部分对象，代表部分的对象不能共享。


## 继承中  构造函数 和 析构函数 

    构造函数是对象在创建是调用，析构函数是对象在销毁时调用。但是在继承关系下，无论在对象的创建还是销毁，都会执行父类和子类的构造和析构函数。 它们一般会有以下规则：

    a. 子类对象在创建时会首先调用父类的构造函数;

    b. 父类构造函数执行完毕后,执行子类的构造函数;

    c. 当父类的构造函数中有参数时,必须在子类的初始化列表中显示调用

    d. 析构函数执行的顺序是先调用子类的析构函数，再调用父类的析构函数


## 继承和组合一起:
    如果在继承状态下，子类中的成员又含有其他类的对象属性，那么他们之间的构造很析构调用顺序，遵循以下原则：

    a. 先调用父类的构造函数,再调用组合对象的构造函数,最后调用自己的构造函数;

    b. 先调用自己的析构函数,再调用组合对象的析构函数,最后调用父类的析构函数。


## 重写父类方法
    在继承中，有时候父类的函数功能并不够强大，子类在继承之后，可以对其进行增强扩展。
    如果还想调用你父类的函数，可以使用 父类::函数名() 访问【在父类的基础上加以改造】


## 多继承 
    C++ 允许存在多继承，也就是一个子类可以同时拥有多个父类。只需要在继承时，使用逗号进行分割即可。


    多继承形式下的构造函数和单继承形式基本相同，只是要在子类的构造函数中调用多个父类的构造函数 。 他们调用的顺序由定义子类时，继承的顺序决定。


## 类的前置声明 
一般来说，类和 变量是一样的，必须先声明然后再使用，如果在某个类里面定义类另一个类的对象变量，那么必须在前面做前置声明，才能编译通过。

    class father; //所有前置声明的类，在某个类中定义的时候，只能定义成引用或者指针。
    class son{
    public:
        //father f0; //因为这行代码，单独拿出来说，会执行father类的无参构造，
        //但是编译器到此处的时候，还不知道B这个类的构造长什么样。
        father &f1;
        father *f2;
    
        son(father &f1 , father *f2):f1(f1),f2(f2){
        }
    };
    
    
    class father{
    
    };
    
    
    int main(){
    
        //  father b; //---> 执行father的构造函数。
        father f1;
        father f2;
    
        son s(f1 ,&f2);
    
        return 0 ;
    }


## 多态 http://robot.czxy.com/docs/cpp/day06/01_dynamic/
    多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

    C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。为了更为详细的说明多态，此处我们划分为静态多态和 动态多态 两种状态来讲解

### 静态多态 
    静态多态是编译器在编译期间完成的，在编译期间就确定了调用哪个函数。
    该种方式的出现有两处地方： 函数重载 和 泛型编程(函数模板).

### 动态多态 
    一般发生在继承中，
    它是在程序运行时根据父类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。

    动态多态的必须满足两个条件：
        父类中必须包含虚函数，并且子类中一定要对父类中的虚函数进行重写。
        通过父类对象的指针或者引用调用这个函数。

### 静态类型  动态类型
静态类型：不需要运行，编译状态下即可知晓具体的类型
    #include<string>
    using namespace std;
    int main(){
        //编译状态下，即可知晓 a,b的类型。
        int a = 3;
        string b = "abc";
        return 0 ;
    }

动态类型: 只有真正运行代码了，才能知晓具体的类型
    class Father{
        public:
        void test(){}
    };
    class Child:public Father{
        public:
        void test(){}
    };
    int main(){
        Father &f = Child();
        //f在编译时，类型是Father ，
        //但在运行时，真正的类型是Child来决定。

        f.test(); // 由于编译器默认采用的是 编译期间的函数，所以此时调用的是father test()

        return 0 ;
    }

### 虚函数  
    C++中的虚函数的作用主要是实现了多态的机制 ， 有了虚函数就可以在父类的指针或者引用指向子类的实例的前提下，然后通过父类的指针或者引用调用实际子类的成员函数。这种技术让父类的指针或引用具备了多种形态。定义虚函数非常简单，只需要在函数声明前，加上 virtual 关键字即可。 在子类的函数上添加 virtual 关键字，可使子类的函数也变成虚函数。

    如果父类指针指向的是一个父类对象，则父类的虚函数被调用 ，如果父类指针指向的是一个子类对象，则子类的虚函数被调用。


#### 虚函数的工作原理 
    http://robot.czxy.com/docs/cpp/day06/01_dynamic/#2_3
    了解虚函数的工作原理，有助于理解虚函数。

    通常情况下，编译器处理虚函数的方法是： 给每一个对象添加一个隐藏指针成员，它指向一个数组，数组里面存放着对象中所有函数的地址。这个数组称之为虚函数表（virtual function table ） 。表中存储着类对象的虚函数地址。

    父类对象包含的指针，指向父类的虚函数表地址，子类对象包含的指针，指向子类的虚函数表地址。

    如果子类重新定义了父类的函数，那么函数表中存放的是新的地址，如果子类没有重新定义，那么表中存放的是父类的函数地址。

    若子类有自己虚函数，则只需要添加到表中即可。

#### 构造函数可以是虚函数吗？
    构造函数不能为虚函数 , 因为虚函数的调用，需要虚函数表(指针)，而该指针存在于对象开辟的空间中，而对象的空间开辟依赖构造函数的执行，这就是鸡和蛋的矛盾问题了。


#### 析构函数可以是虚函数吗？
    在继承体系下， 如果父类的指针可以指向子类对象，这就导致在使用 delete 释放内存时，却是通过父类指针来释放，这会导致父类的析构函数会被执行，而子类的析构函数并不会执行，此举有可能导致程序结果并不是我们想要的。究其原因，是因为静态联编的缘故，在编译时，就知道要执行谁的析构函数。
    为了解决这个问题，**需要把父类的析构函数变成虚拟析构函数**，也就是加上 virtual的定义。一旦父类的析构函数是虚函数，那么子类的析构函数也将自动变成虚函数。

    一句话概括： 继承关系下，所有人的构造都不能是虚函数，并且所有人的析构函数都必须是虚函数。

    只要在父亲的析构函数加上 virtual ，那么所有的析构函数都变成 虚函数
    #include <iostream>
    using namespace std;
    class father{
     public:
        virtual ~father(){
            cout << "执行父类析构函数" << endl;
        }
    };
    
    class son : public father{
        ~son(){
             cout << "执行子类析构函数" << endl;
        }
    };
    int main(){
        father *f = new son(); //父类指针指向子类对象
        //创建的是子类对象，理应执行子类的析构函数
        delete f;
        return 0 ;
    }

## 纯虚函数(抽象类)
    http://robot.czxy.com/docs/cpp/day06/01_dynamic/#7
    纯虚函数是一种特殊的虚函数，C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。C++中的纯虚函数更像是“只提供声明，没有实现”，是对子类的约束。

    还有 接口，其实就是用于描述行为和功能，并不会给出具体的实现。C++中没有提供类似interface 这样的关键字来定义接口 ， 纯虚函数往往承担起了这部分功能，可以看成是对子类的一种约束。


    纯虚函数就是没有虚函数没有函数体，而是换成 =0。

    抽象类的一些特征
        如果有一个类当中有纯虚函数，那么这个类就是抽象类
        抽象类是无法创建对象的，因为一旦能够创建对象，里面的纯虚函数没有函数体，也就不知道要执行什么逻辑了，所以禁止抽象类创建对象。
        抽象类当中也可以有普通的成员函数，虽然父类不能创建对象，但是子类可以创建，所以这些函数可以由子类访问。
        如果一个子类继承了一个父类（父类是抽象类），那么子类就必须重写所有的纯虚函数，否则视子类为抽象类，因为继承体系下，等同于子类拥有了和父类一样的代码。

## 关于虚函数 和 纯虚函数 
    虚函数，子类不一定要重写该函数。
    但是对于纯虚函数，子类一定要重写该函数,不然无法实例化该类。
    
## override 关键字 
    在继承关系下，子类可以重写父类的函数，但是有时候担心程序员在编写时，有可能因为粗心写错代码。所以在C++ 11中，推出了 override 关键字，用于表示子类的函数就是重写了父类的同名函数 。 不过值得注意的是，override 标记的函数，必须是虚函数。

    override 并不会影响程序的执行结果，仅仅是作用于编译阶段，用于检查子类是否真的重写父类函数
    #include <iostream>
    using namespace std;
    class father{
    public:
        virtual void run(){
            cout << "父亲在跑步" << endl;
        }
    };
    
    
    class son : public father{
    public:
       virtual  void run() override{ //表示重写父类的函数
            cout << "孩子在跑步" << endl;
        }
    };
## final 关键字 
    在c++11 推出了final关键字，其作用有两个： (1)、禁止虚函数被重写；(2)、禁止类被继承。
    注意： 只有虚函数才能被标记为final ，其他的普通函数无法标记final。

    // 1 标记在 类上 
    class person final{ //表示该类是最终类，无法被继承
    };
    //编译错误，无法被继承。
    class student : public person{
    
    };

    // 2 标记在 虚函数上 
    class person {
    virtual void run() final{ //表示该方法时最终方法，无法被重写
    }
    };
    class student : public person{
        //编译错误，方法无法被重写。
        void run(){
        }
    };

## =delete 和 =default
    http://robot.czxy.com/docs/cpp/day06/01_dynamic/#6-delete-default    
    这两个关键字平常使用的不多，一般出现在类的特殊成员函数上。=delete 用于表示该函数禁止被调用，=default表示使用编译器默认提供的函数功能。

    // 关于 =default
    一旦定义了有参构造函数之后，编译器将不会替我们生成无参构造函数 。 此时可以自己编写无参构造函数（哪怕函数体是空的），但是此举增加了程序员的编程工作量。更值得一提的是，手动定义的无参构造函数的代码执行效率要低于编译器自动生成的无参构造函数。
     










