## http://robot.czxy.com/docs/cpp/day10/01_make_cmake/


## 子工程  
    每一个子工程都需要有自己的CMakeLists.txt 并且在外部主工程的CMakeLists.txt中注册子工程。


## 导入第三方依赖
    在C/C++中，项目最终都会分成两个部分内容，一个是 头文件( .h ) 一部分是源文件( .cpp ) 。 
    如果要编写好的功能给其他程序使用，通常会把源文件打包形成一个库文件(.a .so)文件 。 值得注意的是，头文件一般不会打包到库中，因为头文件仅仅只是声明而已。 库也增加了代码的重用性、提高编码的效率，也可看看成是对源码的一种保护。

### 什么是库
    库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常 。 本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib） 和 动态库（.so、.dll）

### 静态库 .a 
    静态库最终需要和使用的源程序，打包到一起形成一个新的可执行程序。这就使得有关程序运行依赖的库已经在程序中包含，即便到了客户机上，也能够运行。静态库对程序的更新、部署和发布页会带来麻烦。如果静态库更新了，所有使用它的应用程序都需要重新编译、发布给用户。 


### 动态库 .so
    动态库在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。


    动态库用的一般比较多一些~
    使用命令生成 动态库  
    g++ -fPIC -shared fuck.cpp -o fuck.so

## sub02 演示了 find_package 的使用  


